<!-- cribtutor-stl by NewForester is licensed under a Creative Commons Attribution-ShareAlike 4.0 International Licence. -->

<h1> STL Algorithms </h1>

<h2> Other Algorithms </h2>

Unless otherwise stated, to use any of these algorithms, include &l1;algorithm&gt;.


<h3> Permutations </h3>

Two algorithms allow progression through all the permutations of a sequence.

<p>
<ol><!-- Shuffle List --><li>
<em>next_permutation</em>(first,last[,bfp])
reorders the range &apos;[first,last)&apos; to form the next permutation.
It does nothing and returns false if the sequence is that of the final permutation.
</li><li>
<em>prev_permutation</em>(first,last[,bfp])
reorders the range &apos;[first,last)&apos; to form the previous permutation.
It does nothing and returns false if the sequence is that of the first permutation.
</li></ol>
</p>

<p>
The first permutation may be generated by using <em>sort</em>() to order the sequence.
An <em>alternative</em> sort order may be provided using the optional binary comparator &apos;bfp&apos;.
</p>


<h3> Heap Operations </h3>

<p>
There is heap, the data structure, and heap, the memory allocator.
Here we are concerned with the first of these.
</p>

<p>
A <em>heap</em> is one maximally efficient implementation of
the <em>priority queue</em> abstract data type.
</p>

<p>
<em>heapsort</em> is an in-place sort that
first makes a heap out of an unordered sequence
and then an ordered sequence out of the heap.
In the worse case, it has better performance than <em>quicksort</em>.
</p>

<p>
The STL heap algorithms may take an optional <em>comparator</em> (&apos;bfp&apos;)
as an <em>alternative</em> to the default <em>less</em>&lt;&gt;.
</p>


<p>
The same comparator should be used for all operations on the same heap.
<ol><!-- Shuffle List --><li>
<em>make_heap</em>(first,last[,bfp])
shuffles the (unordered) range &apos;[first,last)&apos; into a heap.
</li><li>
<em>sort_heap</em>(first,last[,bfp])
sorts the range &apos;[first,last)&apos; that is already in heap order.
</li><li>
<em>push_heap</em>(first,last[,bfp])
reshuffles the range &apos;[first,last)&apos; into a heap
assuming [first,last-1) is already a heap.
</li><li>
<em>pop_heap</em>(first,last[,bfp])
moves the first value-object in the heap [first,last) to the end
and reshuffles the range &apos;[first,last-1)&apos; into a heap.
</li></ol>
</p>

<p>
To push onto a heap:
<pre>
    sequence.push_back(vobj);
    sequence.push_heap(sequence.begin(),sequence.end());
</pre>
</p>

<p>
To pop from a heap:
<pre>
    vobj = sequence.front();

    sequence.pop_heap(sequence.begin(),sequence.end());
    sequence.pop_back();
</pre>
</p>


<h3> Uninitialised Memory Operations </h3>

<p>
The algorithms may be used to create a sequence of value-objects in uninitialised memory.
</p>

<p>
They use <em>placement new</em> to copy objects instead of <em>operator=</em>.
</p>

<!-- Since these a declared as requiring forward iterators
and raw memory iterators are described as output iterators,
the relationship between the two is unclear. -->

<p>
To use them include the &lt;<em>memory</em>&gt; header file.
</p>

<p>
<ol><!-- Shuffle List --><li>
<em>uninitialized_copy</em>(first,last,dest)
copies the range '[first,last}' to '[dest,...)'.
</li><li>
<em>uninitialized_fill</em>(first,last,v_obj)
overwrites the range '[first,last)' with copies of 'v_obj'.
</li><li>
<em>uninitialized_fill_n</em>(first,nn,v_obj)
overwrites the range '[first,...)' with 'nn' copies of 'v_obj'.
</li></ol>
</p>
